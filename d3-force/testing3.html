<!-- 
    Adapted from:
    https://github.com/ninjaconcept/d3-force-directed-graph/blob/master/example/4-dynamic-updates.html 
-->

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Force-Directed Graph</title>
  <style>
    /* Add any CSS styles here */
  </style>
</head>
<!-- <body style="background-color:#d3d3d3"> -->
<body>  
    <div id="container" style="display: flex;">
        <svg id="svg" style="width: 80%; height: 200%;"></svg>
        <div id="textContainer" style="width: 20%;"></div>
    </div>
    <svg>
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="7"
            refX="20" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" />
          </marker>
        </defs>
        <!-- Your graph elements -->
      </svg>
      <script src="https://d3js.org/d3.v4.min.js"></script>
  <script>
    // 11ur D3.js code here

    var baseNodes = [
  { id: "0", group: 0, label: "0", level: 1 },
  { id: "1"   , group: 0, label: "1"   , level: 2 },
  { id: "2"   , group: 0, label: "2"   , level: 2 },
  { id: "3"   , group: 0, label: "3"  , level: 2 },
  { id: "4"   , group: 0, label: "4"    , level: 2 },
  { id: "5", group: 1, label: "5", level: 1 },
  { id: "6"   , group: 1, label: "6"   , level: 2 },
  { id: "7"   , group: 1, label: "7"   , level: 2 },
  { id: "8"  , group: 2, label: "8"   , level: 1 },
  { id: "9"  , group: 2, label: "9"   , level: 2 },
  { id: "10"  , group: 2, label: "10"  , level: 2 }
]

let adjList = [
    {id: "0", neighbours: ["1", "2", "3", "4"]},
    {id: "5", neighbours: ["6", "7"]},
    {id: "8", neighbours: ["9", "10"]},
    {id: "2", neighbours: ["4"]},
    {id: "9", neighbours: ["6"]},
    {id: "4", neighbours: ["7"]},
    {id: "1", neighbours: ["0", "2"]},
    {id: "3", neighbours: ["6"]},
    {id: "6", neighbours: []},
    {id: "7", neighbours: []},
    {id: "10", neighbours: []},
]

isDirectedGraph = true;


var baseLinks = [];
    adjList.forEach(node => {
        node.neighbours.forEach(neighbour => {
            baseLinks.push({
                target: node.id,
                source: neighbour,
                strength: 0.1,
                // weight: '1'
            })
        })
    });

// var baseLinks = [
// 	{ target: "0", source: "1" , strength: 0.1 },
// 	{ target: "0", source: "2" , strength: 0.1 },
//   { target: "0", source: "3" , strength: 0.1 },
//   { target: "0", source: "4" , strength: 0.1 },
//   { target: "5", source: "6" , strength: 0.1 },
//   { target: "5", source: "7" , strength: 0.1 },
//   { target: "8"  , source: "9", strength: 0.1 },
//   { target: "8"  , source: "10", strength: 0.1 },
//   { target: "2"   , source: "4" , strength: 0.1 },
//   { target: "9"  , source: "6" , strength: 0.1 },
//   { target: "4"   , source: "7" , strength: 0.1 },
//   { target: "1"   , source: "2" , strength: 0.1 },
//   { target: "3"   , source: "6" , strength: 0.1 },
// ]

var nodes = [...baseNodes]
var links = [...baseLinks]

var highlightedNodes = []

var width = window.innerWidth
var height = window.innerHeight

var svg = d3.select('svg')
svg.attr('width', width).attr('height', height)

var linkElements,
  nodeElements,
  textElements

// we use svg groups to logically group the elements together
var linkGroup = svg.append('g').attr('class', 'links')
var nodeGroup = svg.append('g').attr('class', 'nodes')
var textGroup = svg.append('g').attr('class', 'texts')

// we use this reference to select/deselect
// after clicking the same element twice
var selectedId

// simulation setup with all forces
var linkForce = d3
  .forceLink()
  .id(function (link) { return link.id })
  .strength(function (link) { return link.strength })

var simulation = d3
  .forceSimulation()
  .force('link', linkForce)
  .force('charge', d3.forceManyBody().strength(-120))
  .force('center', d3.forceCenter(width / 2, height / 2))

var dragDrop = d3.drag().on('start', function (node) {
  node.fx = node.x
  node.fy = node.y
}).on('drag', function (node) {
  simulation.alphaTarget(0.2).restart()
  node.fx = d3.event.x
  node.fy = d3.event.y
}).on('end', function (node) {
  if (!d3.event.active) {
    simulation.alphaTarget(0)
  }
  node.fx = null
  node.fy = null
})

function updateGraph() {
  // texts
  textElements = textGroup.selectAll('text')
    .data(nodes, function (node) { return node.id })
    .style("font-family", "Helvetica")

  textElements.exit().remove()

  var textEnter = textElements
    .enter()
    .append('text')
    .text(function (node) { return node.label })
    .attr('font-size', 15)
    .attr('dx', 0)
    .attr('dy', 5)
    .attr('fill', 'white')


  textElements = textEnter.merge(textElements)

  // Update text content based on node labels
  textElements
    .text(function (node) { return node.label })

    // Additional styling for text inside the circles
  textElements
    .attr('text-anchor', 'middle') // Center the text horizontally
    .attr('domin6-baseline', 'middle') // Center the text vertically


  // links
  linkElements = linkGroup.selectAll('line')
    .data(links, function (link) {
      return link.target.id + link.source.id
    })

  linkElements.exit().remove()

  var linkEnter = linkElements
    .enter().append('line')
    .attr('stroke-width', 1)
  .attr('stroke', 'rgba(50, 50, 50, 0.2)')
  .attr('marker-end', isDirectedGraph ? 'url(#arrowhead)' : null)
  .attr('x1', function (link) { return link.source.x })
  .attr('y1', function (link) { return link.source.y })
  .attr('x2', function (link) { return link.target.x })
  .attr('y2', function (link) { return link.target.y })
  
  linkElements = linkEnter.merge(linkElements)

  

  // nodes
  nodeElements = nodeGroup.selectAll('circle')
    .data(nodes, function (node) { return node.id })

  nodeElements.exit().remove()

  var nodeEnter = nodeElements
    .enter()
    .append('circle')
    .attr('r', 10)
    .attr('fill', 'gray')
    // .attr('fill', function (node) { return node.level === 1 ? 'red' : 'gray' })
    .call(dragDrop)

  nodeElements = nodeEnter.merge(nodeElements)

    // Update node color based on level
    nodeElements
    .transition()
    .duration(0) // longer time for gradual highlighting doesn't work rn
    .attr('fill', node => { return highlightedNodes.includes(node.id) ? '#BC544B' : '#73A5C6' })


}


function updateSimulation() {
  updateGraph();

  simulation.nodes(nodes).on('tick', () => {
    nodeElements
      .transition() // Apply transition
      .duration(50) // Set duration in milliseconds
      .attr('cx', function (node) { return node.x })
      .attr('cy', function (node) { return node.y });
      
    textElements
      .transition()
      .duration(50)
      .attr('x', function (node) { return node.x })
      .attr('y', function (node) { return node.y });
      
    linkElements
      .transition()
      .duration(50)
      .attr('x1', function (link) { return link.source.x })
      .attr('y1', function (link) { return link.source.y })
      .attr('x2', function (link) { return link.target.x })
      .attr('y2', function (link) { return link.target.y });
  });

  simulation.force('link').links(links);
  simulation.alphaTarget(0.2).restart();
}


// last but not least, we call updateSimulation
// to trigger the initial render
updateSimulation()

var textContainer = d3.select("#textContainer");

function updateText() {
  let adjListString = '<strong style="font-weight: bold; font-family: \'Open Sans\', sans-serif;">Adjacency list representation:</strong><br>';
  adjList.forEach(node => {
    adjListString += '<span style="font-weight: bold; color: #BC544B; font-family: \'Open Sans\', sans-serif;">' + node['id'] + ':</span> ';
    node.neighbours.forEach((neighbour, index) => {
      adjListString += '<span style="color: #73A5C6; font-family: \'Open Sans\', sans-serif;">' + neighbour + '</span>';
      adjListString += index < node.neighbours.length - 1 ? ' <span style="color: #73A5C6; font-family: \'Open Sans\', sans-serif;">⇨</span> ' : '';
    });
    adjListString += '<br>';
  });
  textContainer.html(adjListString);
}


updateText();



// Mock tests
setTimeout(function() {
    links.push({ target: "10"  , source: "2" , strength: 0.1 })
    adjList.find(node => node.id === "10").neighbours.push("2");
    updateText();
    highlightedNodes.push('0')
    updateSimulation()

    // updateTableData(data)

}, 3000);

setTimeout(function() {
    highlightedNodes.pop()
    highlightedNodes.push('6')
    nodes.push({id: '11', group: 0, label: '11', level: 1})
    adjList.push({id: "11", neighbours: []});
    links.push({ target: "10"  , source: "11" , strength: 0.1 })
    adjList.find(node => node.id === "11").neighbours.push("10");
    updateText();
    updateSimulation()
}, 5000);

setTimeout(function() {
    highlightedNodes.pop();
    highlightedNodes.push('5')
    updateSimulation()
}, 6000);
setTimeout(function() {
    highlightedNodes.pop();
    highlightedNodes.push('7')
    updateSimulation()
}, 7000);
setTimeout(function() {
    highlightedNodes.pop();
    highlightedNodes.push('4')
    updateSimulation()
}, 8000);
setTimeout(function() {
    highlightedNodes.pop();
    highlightedNodes.push('2')
    updateSimulation()
}, 9000);
setTimeout(function() {
    highlightedNodes.pop();
    highlightedNodes.push('10');
    nodes.pop();
    links.pop();
    adjList.pop();
    updateText();
    updateSimulation()
}, 10000);

  </script>
</body>
</html>


<!-- 
    - Animate adding new link gradually                 done
    - Highlight and unhighlight a node                  done
    - Support weighted graphs
    - Add arrows to edges                               done
    - support bidirectional edges                       done
    - Support undirected graphs (kinda works alr)       done
    - Refine nodes and edges data representation
    - make graph move around less                       done
    - highlight nodes + texts gradually
    - visualise adding a node                           done
    - visualise removing a node                         done
    - visualise changes gradually
    - ensure everything remains on screen
    - ↳ support disjoint graphs better
    - show adj list                                     done
    - format adj list better
    - remove on click functionality                     done
    - changelog?
    - display node ids in circles                       done
    - position text underneath circles so 
      circles can be dragged
    - refactor code to ts, clean up, add more comments
    - look into using svg.js for the node objects
 -->